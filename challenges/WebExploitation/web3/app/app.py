from flask import Flask, render_template, request, redirect, url_for, session, flash, abort, Response
from faker import Faker
from os import urandom
from threading import Thread
import time
import sys
from datetime import timedelta
import random
import string

PORT=4444
STOP_SIG = False

fake = Faker()

app = Flask(__name__)
app.secret_key = urandom(32)

# Set session lifetime to 12 hours
app.permanent_session_lifetime = timedelta(hours=12)

def random_string(length=12):
    chars = string.ascii_letters + string.digits
    return ''.join(random.choice(chars) for _ in range(length))

admin_secret="" # holds flag from cmd arg
chat_messages = []
reported_messages = []

@app.route("/robots.txt")
def robots():
    return Response("User-agent: *\nDisallow: /", mimetype="text/plain")

@app.route('/')
def home():
    if not session:
        return redirect(url_for('login'))
    return render_template('room.html')

def psuedo_talk():
    global STOP_SIG, active_sess, chat_messages

    while (STOP_SIG == False):
        # Simulating new messages being added every time
        chat_msg = generate_message()
        if len(chat_messages) >= 50:
            # drop first message (dont flood memory with large number of strings)
            chat_messages = chat_messages[:1]
        chat_messages.append(chat_msg)
        time.sleep(5)

# Dont feel like letting everyone else see this
@app.route('/get_messages')
def get_messages():
    global chat_messages
    
    if not session:
        return redirect(url_for('login'))

    return {'messages': chat_messages}

# uses faker to generate random messages
def generate_message():
    # Generate random message
    random_message = fake.sentence()

    # Generate random user
    random_user = fake.user_name()

    # Combine into a message object
    message = {"user": random_user, "message": random_message}
    return message

@app.route('/send_message', methods=['POST'])
def send_messages():
    username = ""
    if request.remote_addr == '127.0.0.1': # admin fetch is coming from localhost
        print("request from admin")
        username = "admin"
    else:
        if not session:
            print("no active session")
            return redirect(url_for('login'))
        else:
            username = str(session['username'])
    
    print("finding message. . .")
    message = request.form.get('message')
    if message:
        print("|___ sending message!")
        chat_messages.append({"user": username, "message": message})
        return "Message Sent Successfully!"
    else:
        return "No Message Provided!"

# Ran by a different thread
def bot_main():
    global STOP_SIG
    while (STOP_SIG == False):
        time.sleep(5)
        admin_bot()

# need to use selenium or something to simulate running a browser so we get XSS Triggering
def admin_bot():
    try:
        global admin_secret

        from selenium import webdriver
        from selenium.webdriver.firefox.service import Service
        from selenium.webdriver.common.by import By
        from selenium.webdriver.firefox.options import Options

        print(f'Setting Admin Cookie: {admin_secret}')

        # Define your desired cookie
        cookie = {
            'name': 'admin_token',
            'value': admin_secret, # holds the ctf flag
            'path': '/',
            'secure': False,
            'httpOnly': False, # JS can access this cookie
            'sameSite': 'Lax' # Needed because secure is false
        }

        # Setup Firefox options
        firefox_options = Options()
        firefox_options.add_argument("--headless")  # Optional: Run Firefox in headless mode

        # Initialize the Firefox WebDriver
        service = Service(executable_path="/usr/local/bin/geckodriver") # specifying where the driver is located
        driver = webdriver.Firefox(service=service, options=firefox_options)

        # Open a page on the same domain as the cookie
        driver.get(f'http://localhost:{PORT}')  # Replace PORT with your actual port, e.g., 8080

        # Set the cookie after the page loads
        driver.add_cookie(cookie)

        # Refresh the page to apply the cookie
        driver.refresh()

        # Perform any actions with the cookie, for example, login or interact with the page
        time.sleep(2)  # Wait to ensure the cookie is set and the page loads
        driver.get(f'http://localhost:{PORT}/admin')  # Replace PORT with your actual port

        # Example interaction: Get page title
        print(driver.title)
        time.sleep(5)

        # Cleanup: Close the browser
        driver.quit()
    except Exception as e:
        print(f"Error: {e}")

@app.route('/admin')
def admin():
    if request.remote_addr != '127.0.0.1':
        abort(403)
    return render_template('admin.html')

@app.route('/get_reports')
def get_reports():
    if request.remote_addr != '127.0.0.1':
        abort(403)
    return reported_messages

@app.route('/report', methods=['GET', 'POST'])
def report_message():
    if request.method == 'POST':
        message_id = request.form.get('message_id')
        message_sender = request.form.get('message_sender')
        description = request.form.get('description')
        # send data to a collection that gets rendered by a special page a BOT will view
        if message_id and message_sender:
            if not description: # for blank descriptions (not-req form attribute)
                description = "N/A"

            reported_messages.append({
                "message_id":message_id,
                "message_sender":message_sender,
                "description":description,
            })

            return "Report has been Successfully Filed! An Administrator will review your report!"
        else:
            return "REQUIRES 'message_id' and 'message_sender'"
    message_id = request.args.get('message_id')
    message_sender = request.args.get('message_sender')
    if message_id and message_sender:
        return render_template('report.html', message_id=message_id, message_sender=message_sender)
    else:
        return "REQUIRES 'message_id' and 'message_sender'"

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if username and password:
            session['username'] = username
            session.permanent = True # ensures the session expires in 12 hours
            return redirect(url_for('home'))
        else:
            flash('Invalid credentials, please try again.', 'danger')
            return redirect(url_for('login'))

    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('username', None)
    return redirect(url_for('login'))

def main():
    global STOP_SIG, admin_secret

    if len(sys.argv) != 2:
        print("Usage: python3 app.py [FLAG]")
        return
    
    admin_secret = str(sys.argv[1])

    print("STARTING BOT")
    # Trigger a bot action after a few seconds (maybe with a thread)
    t = Thread(target=bot_main)
    t.start()

    t2 = Thread(target=psuedo_talk)
    t2.start()

    print("STARTING SERVICE")
    app.run(debug=False, host="0.0.0.0", port=PORT)
    print("STOPPING SERVICE")

    STOP_SIG = True
    t.join(100)
    t2.join(100)
    print("STOPPING BOT")

if __name__ == '__main__':
    main()