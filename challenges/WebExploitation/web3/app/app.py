from flask import Flask, render_template, request, redirect, url_for, session, flash, abort
from faker import Faker
from os import urandom
from threading import Thread
import time

PORT=4444
STOP_SIG = False

fake = Faker()

app = Flask(__name__)
app.secret_key = urandom(32)

@app.route('/')
def home():
    if not session:
        return redirect(url_for('login'))
    return render_template('room.html')

chat_messages = []

# Dont feel like letting everyone else see this
@app.route('/get_messages')
def get_messages():
    if request.remote_addr != '127.0.0.1':
        abort(403)

    if not session:
        return redirect(url_for('login'))

    # Simulating new messages being added every time    
    chat_messages.append(generate_message())

    return {'messages': chat_messages}

# uses faker to generate random messages
def generate_message():
    # Generate random message
    random_message = fake.sentence()

    # Generate random user
    random_user = fake.user_name()

    # Combine into a message object
    message = {"user": random_user, "message": random_message}
    return message

@app.route('/send_message', methods=['POST'])
def send_messages():
    if not session:
        return redirect(url_for('login'))
    
    message = request.form.get('message')
    if message:
        chat_messages.append({"user": session['username'], "message": message})
        return "Message Sent Successfully!"
    else:
        return "No Message Provided!"

# Ran by a different thread
def bot_main():
    global STOP_SIG
    while (STOP_SIG == False):
        time.sleep(5)
        admin_bot()

# need to use selenium or something to simulate running a browser so we get XSS Triggering
def admin_bot():
    try:
        from selenium import webdriver
        from selenium.webdriver.firefox.service import Service
        from selenium.webdriver.common.by import By
        from selenium.webdriver.firefox.options import Options

        # Define your desired cookie
        cookie = {
            'name': 'admin_token',
            'value': 'KHI{fake_flag}',
            'path': '/',
            'secure': False,
            'httpOnly': False,
            'sameSite': 'None'
        }

        # Setup Firefox options
        firefox_options = Options()
        firefox_options.add_argument("--headless")  # Optional: Run Firefox in headless mode

        # Initialize the Firefox WebDriver
        service = Service()
        driver = webdriver.Firefox(service=service, options=firefox_options)

        # Open a page on the same domain as the cookie
        driver.get(f'http://localhost:{PORT}')  # Replace PORT with your actual port, e.g., 8080

        # Set the cookie after the page loads
        driver.add_cookie(cookie)

        # Refresh the page to apply the cookie
        driver.refresh()

        # Perform any actions with the cookie, for example, login or interact with the page
        time.sleep(2)  # Wait to ensure the cookie is set and the page loads
        driver.get(f'http://localhost:{PORT}/admin')  # Replace PORT with your actual port

        # Example interaction: Get page title
        print(driver.title)
        time.sleep(5)

        # Cleanup: Close the browser
        driver.quit()
    except Exception as e:
        print(f"Error: {e}")

reported_messages = []
@app.route('/admin')
def admin():
    if request.remote_addr != '127.0.0.1':
        abort(403)
    return render_template('admin.html')

@app.route('/get_reports')
def get_reports():
    if request.remote_addr != '127.0.0.1':
        abort(403)
    # { "message_id":message_id, "message_sender":message_sender, "description":description }
    # print(f"reported_messages GETTING -> {reported_messages}")
    return reported_messages

@app.route('/report', methods=['GET', 'POST'])
def report_message():
    if request.method == 'POST':
        message_id = request.form.get('message_id')
        message_sender = request.form.get('message_sender')
        description = request.form.get('description')
        # send data to a collection that gets rendered by a special page a BOT will view
        if message_id and message_sender:
            if not description: # for blank descriptions (not-req form attribute)
                description = "N/A"

            reported_messages.append({
                "message_id":message_id,
                "message_sender":message_sender,
                "description":description,
            })

            return "Report has been Successfully Filed! An Administrator will review your report!"
        else:
            return "REQUIRES 'message_id' and 'message_sender'"
    message_id = request.args.get('message_id')
    message_sender = request.args.get('message_sender')
    if message_id and message_sender:
        return render_template('report.html', message_id=message_id, message_sender=message_sender)
    else:
        return "REQUIRES 'message_id' and 'message_sender'"

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if username and password:
            session['username'] = username
            return redirect(url_for('home'))
        else:
            flash('Invalid credentials, please try again.', 'danger')
            return redirect(url_for('login'))

    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('username', None)
    return redirect(url_for('login'))

def main():
    global STOP_SIG
    print("STARTING BOT")
    # Trigger a bot action after a few seconds (maybe with a thread)
    t = Thread(target=bot_main)
    t.start()

    print("STARTING SERVICE")
    app.run(debug=False, host="0.0.0.0", port=PORT)
    print("STOPPING SERVICE")

    STOP_SIG = True
    t.join(100)
    print("STOPPING BOT")

if __name__ == '__main__':
    main()